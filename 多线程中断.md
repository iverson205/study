---
title: 多线程中断 
tags: Java,多线程,中断
---

# 概念
* 当一个线程调用interrupt,该线程的中断状态被置位（boolean类型)。
* 每个线程都会不时检查自己的状态位以判断线程是否被中断。但是线程如果处于阻塞状态，就没法检查了。这也是产生InterruptException的原因。
* 中断线程不过是引起线程的注意，该线程自己决定何时以何种方式响应中断。也就是说有时候可以不理会中断请求。

# interrupt()方法
## jdk源码
````markdown
```java
public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag
                b.interrupt(this);
                return;
            }
        }
        interrupt0();//再次调用会清除中断标志
    }
```
````

##  方法解析
通过查看源码，可以看到调用interrupt方法本质只是just to set the interrupt flag。设置完成之后，线程根据自身当前的状态做出响应。  
* 非阻塞状态：中断标志设置为true
* 阻塞状态：中断标志设置为true
>wait/sleep/join引起的阻塞，中断标志置为false,抛出InterruptException
>轮询（java.nio.channels.Selectors）引起的线程阻塞，则立即返回，不会抛出异常。（待验证）
>java.nio.channels.InterruptibleChannel进行的io操作引起的阻塞，则会对线程抛出一个ClosedByInterruptedException；（待验证） 

## 正常中断的方法
* 当线程执行完run方法的最后一行成功返回后或者出现了在方法中没有捕获的异常时，线程将终止。  
* Java早期采用stop方法终止线程，但是现在这种方法基本废弃了，因为这种方法不安全。比如，ThreadA从甲的账户向乙转账的过程中被终止，这样就可能出现甲的钱已经转出但是乙却还没收到。也就是具有不确定性。
* Interrupt方法，字面上看可以中断，实际并不可行。一种可行的方案是利用Interrupt方法改变的中断标志，用户自行处理。
````markdown
```java
public void run()
{  
     try
	 {  
         while (true)
		{  
            Thread.sleep(1000l);//阻塞状态，线程被调用了interrupte（）方法，抛出InterruptedException  
               //dosomething  
			   
               boolean isIn = this.isInterrupted();  
                //运行状态，线程被调用了interrupte（）方法，中断标志被设置为true                     
               if(isIn) //非阻塞状态中进行中断线程操作  
					break;//退出循环，中断线程  
           }  
       }
	   catch (InterruptedException e)//阻塞状态中进行中断线程操作  
	   {
          boolean isIn = this.isInterrupted();//退出阻塞状态且中断标志被清除,isIn为false  
          return;//退出run方法，中断线程  
         }  
 }  
 ```
 ````
 # interrupted()"和"isInterrupted()
 ## jdk源码
 ````markdown
 ```java
 public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }

 public boolean isInterrupted() {
        return isInterrupted(false);
    }
	
 private native boolean isInterrupted(boolean ClearInterrupted);
 ```
 ````
 ## 小结
 * 调用Interrupted后，返回当前的中断状态，并重置中断状态为FALSE；
 * 调用isInterrupted后，返回当前的中断状态；
 * 一个细节，Interrupted是静态方法；
 



	