---
title: 关于快速排序
tags: 快速排序,partition,递归
grammar_cjkRuby: true
---
# 1.概述
快速排序通常是用于排序的最佳的实用选择，最坏的情况下时间复杂度为O（n ^2^）,平均情况的时间复杂度为O（nlgn）,另外它还能够进行就地排序，在虚存环境中也能很好的工作。不过它是不稳定的排序！！
# 2.算法描述
快速排序基于分治模式,通过一趟排序将数组切割成两部分，一部分小于参考值，另一部分大于参考值，当然，参考值就是这两部分的分界点。接下来就对切割后的两部分分别按照这种方法进行排序，最终完成对整个数组的排序。
虽然快速排序的思想比较直观，但是具体实现还是会有不同的版本，不同的版本间的效率也会有差异。
# 3.立即刷新型
## 3.1原理演示
%[快速排序](http://v.youku.com/v_show/id_XNDI0ODk4NTMy.html?from=s1.8-1-1.2)
该版本的基本原理是找到了不符合排序的值就和参考值交换位置；
````markdown
````java
	private static void fun(int[] arr, int i, int j)
	{		
		int k = partition(arr,i, j);
		if ((k - i) > 1)
			fun(arr,i, k);
		if ((j - k) > 1)
			fun(arr,k + 1, j);
	}
    
    private static int partition(int[] arr, int m, int n)
	{
		int key=arr[m];
		while(m<n)
		{
			
			while(n>m&&arr[--n]>key);//先从后面扫描，避免数组越界
			
			int tmp2=arr[m];
			arr[m]=arr[n];
			arr[n]=tmp2;
            
			while(n>m&&arr[++m]<key);
			
			int tmp1=arr[m];
			arr[m]=arr[n];
			arr[n]=tmp1;
		}
		return m;
`````
## 3.2推荐版本
该版本来源于《算法导论》，和前一版本相比，数据位置交换的次数减少。主要原因是参考值只在每趟partition完成之后再移动。
````markdown
````java
public void sort_Quick(int [] arr,int i,int j)
{
	if(i<j)
    {
    	int k=partition(arr,i,j);
        sort_Quick(arr,i,k-1);
        sort_Quick(arr,k+1,j);
    }
}

public int partition(int []arr,int i,int j)
{
	int key=arr[j];//选最右端的值为参考值；
    int m=i-1;//记录已排序的元素的位置；
    int n=i;//从最左端开始扫描；
    
    for(;n<j;n++)
    {
    	if(arr[n]<key)//找到符合排序的数，将其插入已排序的序列中
        {
        	m++;
            int tmp=arr[m];
            arr[m]=arr[n];
            arr[n]=tmp;
        }
    }
    //更新参考值的位置
    m=m+1;
    arr[j]=arr[m];
    arr[m]=key;
    //返回分界点的位置
    return m;  
}